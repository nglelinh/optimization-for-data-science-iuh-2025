---
layout: post
title: 02-01-05 Hyperplane
chapter: '02'
order: 4.5
owner: AI Assistant
categories:
- chapter02
lang: en
---

A hyperplane is one of the most fundamental geometric objects in convex optimization and linear algebra. It serves as a building block for understanding more complex convex sets and plays a crucial role in optimization algorithms, machine learning, and geometric analysis.

## Definition of Hyperplane

A **hyperplane** in $$\mathbb{R}^n$$ is a set of the form:

> $$\mathcal{H} = \{x \in \mathbb{R}^n : a^T x = b\}$$

where $$a \in \mathbb{R}^n$$ is a nonzero vector ($$a \neq 0$$) and $$b \in \mathbb{R}$$ is a scalar.

The vector $$a$$ is called the **normal vector** to the hyperplane, and it determines the orientation of the hyperplane. The scalar $$b$$ determines the position of the hyperplane relative to the origin.

### Geometric Interpretation

- In $$\mathbb{R}^2$$: A hyperplane is a **line**
- In $$\mathbb{R}^3$$: A hyperplane is a **plane**  
- In $$\mathbb{R}^n$$ ($$n > 3$$): A hyperplane is an $$(n-1)$$-dimensional subspace

The hyperplane divides the entire space $$\mathbb{R}^n$$ into two **halfspaces**:
- **Positive halfspace**: $$\{x : a^T x \geq b\}$$
- **Negative halfspace**: $$\{x : a^T x \leq b\}$$

## Properties of Hyperplanes

### 1. Affine Set Property
Every hyperplane is an **affine set**. This means that if $$x_1, x_2 \in \mathcal{H}$$, then the entire line passing through them is also contained in $$\mathcal{H}$$:

$$\theta x_1 + (1-\theta) x_2 \in \mathcal{H} \quad \forall \theta \in \mathbb{R}$$

**Proof**: If $$a^T x_1 = b$$ and $$a^T x_2 = b$$, then:
$$a^T(\theta x_1 + (1-\theta) x_2) = \theta a^T x_1 + (1-\theta) a^T x_2 = \theta b + (1-\theta) b = b$$

### 2. Convex Set Property
Since every affine set is convex, hyperplanes are **convex sets**. For any $$x_1, x_2 \in \mathcal{H}$$ and $$\lambda \in [0,1]$$:

$$\lambda x_1 + (1-\lambda) x_2 \in \mathcal{H}$$

### 3. Closed Set Property
Hyperplanes are **closed sets** because they are the level sets of continuous linear functions.

### 4. Dimension
A hyperplane in $$\mathbb{R}^n$$ has dimension $$n-1$$.

## Alternative Representations

### 1. Point-Normal Form
If we know a point $$x_0$$ on the hyperplane and the normal vector $$a$$, the hyperplane can be written as:

$$\mathcal{H} = \{x : a^T (x - x_0) = 0\}$$

This is equivalent to $$a^T x = a^T x_0$$, so $$b = a^T x_0$$.

### 2. Matrix Form
A hyperplane can also be represented using matrix notation. If $$A$$ is a $$1 \times n$$ matrix (row vector), then:

$$\mathcal{H} = \{x : Ax = b\}$$

### 3. Parametric Form
A hyperplane can be parameterized using a basis for its null space. If $$\{v_1, v_2, \ldots, v_{n-1}\}$$ is an orthonormal basis for the null space of $$a^T$$, and $$x_0$$ is any point on the hyperplane, then:

$$\mathcal{H} = \{x_0 + t_1 v_1 + t_2 v_2 + \cdots + t_{n-1} v_{n-1} : t_i \in \mathbb{R}\}$$

## Distance from Point to Hyperplane

The **distance** from a point $$x_0$$ to the hyperplane $$\{x : a^T x = b\}$$ is given by:

$$d(x_0, \mathcal{H}) = \frac{\lvert a^T x_0 - b \rvert}{\lVert a \rVert_2}$$

This formula comes from projecting the vector from any point on the hyperplane to $$x_0$$ onto the normal direction.

### Derivation
Let $$x^*$$ be the closest point on the hyperplane to $$x_0$$. Then $$x^* - x_0$$ is parallel to the normal vector $$a$$:

$$x^* - x_0 = t \frac{a}{\lVert a \rVert_2}$$

Since $$x^* \in \mathcal{H}$$, we have $$a^T x^* = b$$. Substituting:

$$a^T \left(x_0 + t \frac{a}{\lVert a \rVert_2}\right) = b$$

Solving for $$t$$: $$t = \frac{b - a^T x_0}{\lVert a \rVert_2}$$

The distance is $$\lvert t \rvert = \frac{\lvert a^T x_0 - b \rvert}{\lVert a \rVert_2}$$.

## Examples

### Example 1: Line in $$\mathbb{R}^2$$
The hyperplane $$2x_1 + 3x_2 = 6$$ represents a line in the plane.
- Normal vector: $$a = (2, 3)$$
- The line passes through points $$(3, 0)$$ and $$(0, 2)$$
- Distance from origin: $$\frac{\lvert 2 \cdot 0 + 3 \cdot 0 - 6 \rvert}{\sqrt{2^2 + 3^2}} = \frac{6}{\sqrt{13}}$$

### Example 2: Plane in $$\mathbb{R}^3$$
The hyperplane $$x_1 - 2x_2 + x_3 = 4$$ represents a plane in 3D space.
- Normal vector: $$a = (1, -2, 1)$$
- The plane passes through points $$(4, 0, 0)$$, $$(0, -2, 0)$$, and $$(0, 0, 4)$$

### Example 3: Hyperplane through Origin
The hyperplane $$a^T x = 0$$ always passes through the origin and is actually a **subspace** of dimension $$n-1$$.

## Interactive Visualization

<div id="hyperplane-container" style="width: 100%; max-width: 800px; margin: 20px auto;">
    <div id="controls" style="margin-bottom: 20px; text-align: center;">
        <label>Normal vector a₁: <input type="range" id="a1-slider" min="-3" max="3" step="0.1" value="1"></label>
        <span id="a1-value">1.0</span><br>
        <label>Normal vector a₂: <input type="range" id="a2-slider" min="-3" max="3" step="0.1" value="1"></label>
        <span id="a2-value">1.0</span><br>
        <label>Offset b: <input type="range" id="b-slider" min="-5" max="5" step="0.1" value="0"></label>
        <span id="b-value">0.0</span><br>
        <button id="reset-btn">Reset</button>
    </div>
    <canvas id="hyperplane-canvas" width="600" height="400" style="border: 1px solid #ccc; display: block; margin: 0 auto;"></canvas>
    <div id="info" style="text-align: center; margin-top: 10px; font-family: monospace;">
        <p>Hyperplane equation: <span id="equation">x₁ + x₂ = 0</span></p>
        <p>Distance from origin: <span id="distance">0.0</span></p>
    </div>
</div>

<script>
class HyperplaneVisualizer {
    constructor() {
        this.canvas = document.getElementById('hyperplane-canvas');
        this.ctx = this.canvas.getContext('2d');
        this.width = this.canvas.width;
        this.height = this.canvas.height;
        
        // Parameters
        this.a1 = 1;
        this.a2 = 1;
        this.b = 0;
        
        // Scale and offset for coordinate system
        this.scale = 40;
        this.centerX = this.width / 2;
        this.centerY = this.height / 2;
        
        this.setupControls();
        this.draw();
    }
    
    setupControls() {
        const a1Slider = document.getElementById('a1-slider');
        const a2Slider = document.getElementById('a2-slider');
        const bSlider = document.getElementById('b-slider');
        const resetBtn = document.getElementById('reset-btn');
        
        a1Slider.addEventListener('input', (e) => {
            this.a1 = parseFloat(e.target.value);
            document.getElementById('a1-value').textContent = this.a1.toFixed(1);
            this.updateDisplay();
        });
        
        a2Slider.addEventListener('input', (e) => {
            this.a2 = parseFloat(e.target.value);
            document.getElementById('a2-value').textContent = this.a2.toFixed(1);
            this.updateDisplay();
        });
        
        bSlider.addEventListener('input', (e) => {
            this.b = parseFloat(e.target.value);
            document.getElementById('b-value').textContent = this.b.toFixed(1);
            this.updateDisplay();
        });
        
        resetBtn.addEventListener('click', () => {
            this.a1 = 1;
            this.a2 = 1;
            this.b = 0;
            a1Slider.value = 1;
            a2Slider.value = 1;
            bSlider.value = 0;
            document.getElementById('a1-value').textContent = '1.0';
            document.getElementById('a2-value').textContent = '1.0';
            document.getElementById('b-value').textContent = '0.0';
            this.updateDisplay();
        });
    }
    
    updateDisplay() {
        this.draw();
        this.updateInfo();
    }
    
    updateInfo() {
        // Update equation
        const eq = `${this.a1.toFixed(1)}x₁ + ${this.a2.toFixed(1)}x₂ = ${this.b.toFixed(1)}`;
        document.getElementById('equation').textContent = eq;
        
        // Update distance from origin
        const distance = Math.abs(this.b) / Math.sqrt(this.a1 * this.a1 + this.a2 * this.a2);
        document.getElementById('distance').textContent = distance.toFixed(3);
    }
    
    worldToScreen(x, y) {
        return {
            x: this.centerX + x * this.scale,
            y: this.centerY - y * this.scale
        };
    }
    
    draw() {
        // Clear canvas
        this.ctx.clearRect(0, 0, this.width, this.height);
        
        // Draw coordinate system
        this.drawCoordinateSystem();
        
        // Draw hyperplane (line in 2D)
        this.drawHyperplane();
        
        // Draw normal vector
        this.drawNormalVector();
        
        // Draw distance from origin
        this.drawDistanceFromOrigin();
    }
    
    drawCoordinateSystem() {
        this.ctx.strokeStyle = '#ddd';
        this.ctx.lineWidth = 1;
        
        // Grid lines
        for (let i = -10; i <= 10; i++) {
            if (i === 0) continue;
            
            // Vertical lines
            const x = this.centerX + i * this.scale;
            this.ctx.beginPath();
            this.ctx.moveTo(x, 0);
            this.ctx.lineTo(x, this.height);
            this.ctx.stroke();
            
            // Horizontal lines
            const y = this.centerY + i * this.scale;
            this.ctx.beginPath();
            this.ctx.moveTo(0, y);
            this.ctx.lineTo(this.width, y);
            this.ctx.stroke();
        }
        
        // Axes
        this.ctx.strokeStyle = '#666';
        this.ctx.lineWidth = 2;
        
        // X-axis
        this.ctx.beginPath();
        this.ctx.moveTo(0, this.centerY);
        this.ctx.lineTo(this.width, this.centerY);
        this.ctx.stroke();
        
        // Y-axis
        this.ctx.beginPath();
        this.ctx.moveTo(this.centerX, 0);
        this.ctx.lineTo(this.centerX, this.height);
        this.ctx.stroke();
        
        // Labels
        this.ctx.fillStyle = '#666';
        this.ctx.font = '12px Arial';
        this.ctx.fillText('x₁', this.width - 20, this.centerY - 10);
        this.ctx.fillText('x₂', this.centerX + 10, 15);
    }
    
    drawHyperplane() {
        if (Math.abs(this.a1) < 1e-10 && Math.abs(this.a2) < 1e-10) return;
        
        this.ctx.strokeStyle = '#2196F3';
        this.ctx.lineWidth = 3;
        
        // Find two points on the line a1*x1 + a2*x2 = b
        let x1_start, y1_start, x1_end, y1_end;
        
        if (Math.abs(this.a2) > 1e-10) {
            // Line is not vertical
            x1_start = -10;
            y1_start = (this.b - this.a1 * x1_start) / this.a2;
            x1_end = 10;
            y1_end = (this.b - this.a1 * x1_end) / this.a2;
        } else {
            // Line is vertical
            x1_start = x1_end = this.b / this.a1;
            y1_start = -10;
            y1_end = 10;
        }
        
        const start = this.worldToScreen(x1_start, y1_start);
        const end = this.worldToScreen(x1_end, y1_end);
        
        this.ctx.beginPath();
        this.ctx.moveTo(start.x, start.y);
        this.ctx.lineTo(end.x, end.y);
        this.ctx.stroke();
        
        // Label
        const midX = (start.x + end.x) / 2;
        const midY = (start.y + end.y) / 2;
        this.ctx.fillStyle = '#2196F3';
        this.ctx.font = 'bold 14px Arial';
        this.ctx.fillText('Hyperplane', midX + 10, midY - 10);
    }
    
    drawNormalVector() {
        if (Math.abs(this.a1) < 1e-10 && Math.abs(this.a2) < 1e-10) return;
        
        // Normalize the normal vector for display
        const norm = Math.sqrt(this.a1 * this.a1 + this.a2 * this.a2);
        const na1 = this.a1 / norm;
        const na2 = this.a2 / norm;
        
        // Find a point on the hyperplane closest to origin
        const t = this.b / (this.a1 * this.a1 + this.a2 * this.a2);
        const px = t * this.a1;
        const py = t * this.a2;
        
        const startPoint = this.worldToScreen(px, py);
        const endPoint = this.worldToScreen(px + na1 * 2, py + na2 * 2);
        
        // Draw normal vector
        this.ctx.strokeStyle = '#FF5722';
        this.ctx.lineWidth = 2;
        this.ctx.beginPath();
        this.ctx.moveTo(startPoint.x, startPoint.y);
        this.ctx.lineTo(endPoint.x, endPoint.y);
        this.ctx.stroke();
        
        // Draw arrowhead
        const angle = Math.atan2(endPoint.y - startPoint.y, endPoint.x - startPoint.x);
        const arrowLength = 10;
        this.ctx.beginPath();
        this.ctx.moveTo(endPoint.x, endPoint.y);
        this.ctx.lineTo(
            endPoint.x - arrowLength * Math.cos(angle - Math.PI / 6),
            endPoint.y - arrowLength * Math.sin(angle - Math.PI / 6)
        );
        this.ctx.moveTo(endPoint.x, endPoint.y);
        this.ctx.lineTo(
            endPoint.x - arrowLength * Math.cos(angle + Math.PI / 6),
            endPoint.y - arrowLength * Math.sin(angle + Math.PI / 6)
        );
        this.ctx.stroke();
        
        // Label
        this.ctx.fillStyle = '#FF5722';
        this.ctx.font = 'bold 12px Arial';
        this.ctx.fillText('Normal vector a', endPoint.x + 5, endPoint.y - 5);
    }
    
    drawDistanceFromOrigin() {
        if (Math.abs(this.a1) < 1e-10 && Math.abs(this.a2) < 1e-10) return;
        
        // Find closest point on hyperplane to origin
        const t = this.b / (this.a1 * this.a1 + this.a2 * this.a2);
        const px = t * this.a1;
        const py = t * this.a2;
        
        const origin = this.worldToScreen(0, 0);
        const closestPoint = this.worldToScreen(px, py);
        
        // Draw distance line
        this.ctx.strokeStyle = '#4CAF50';
        this.ctx.lineWidth = 2;
        this.ctx.setLineDash([5, 5]);
        this.ctx.beginPath();
        this.ctx.moveTo(origin.x, origin.y);
        this.ctx.lineTo(closestPoint.x, closestPoint.y);
        this.ctx.stroke();
        this.ctx.setLineDash([]);
        
        // Draw origin point
        this.ctx.fillStyle = '#4CAF50';
        this.ctx.beginPath();
        this.ctx.arc(origin.x, origin.y, 4, 0, 2 * Math.PI);
        this.ctx.fill();
        
        // Draw closest point
        this.ctx.beginPath();
        this.ctx.arc(closestPoint.x, closestPoint.y, 4, 0, 2 * Math.PI);
        this.ctx.fill();
        
        // Label
        const midX = (origin.x + closestPoint.x) / 2;
        const midY = (origin.y + closestPoint.y) / 2;
        this.ctx.fillStyle = '#4CAF50';
        this.ctx.font = '12px Arial';
        this.ctx.fillText('Distance', midX + 5, midY + 5);
    }
}

// Initialize visualization when page loads
document.addEventListener('DOMContentLoaded', function() {
    new HyperplaneVisualizer();
});
</script>

## Relationship to Other Concepts

### Connection to Affine Sets
Every hyperplane is an affine set, but not every affine set is a hyperplane. Hyperplanes are specifically $$(n-1)$$-dimensional affine sets in $$\mathbb{R}^n$$.

### Connection to Linear Algebra
The hyperplane $$\{x : a^T x = b\}$$ is the **level set** of the linear function $$f(x) = a^T x$$ at level $$b$$. The gradient of this function is constant and equal to $$a$$, which explains why $$a$$ is perpendicular to the hyperplane.

### Connection to Optimization
In constrained optimization, equality constraints often define hyperplanes that restrict the feasible region. The method of Lagrange multipliers exploits the fact that at an optimal point, the gradient of the objective function is parallel to the normal vector of the constraint hyperplane.