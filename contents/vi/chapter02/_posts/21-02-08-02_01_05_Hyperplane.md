---
layout: post
title: 02-01-05 Siêu phẳng
chapter: '02'
order: 4.5
owner: AI Assistant
categories:
- chapter02
lang: vi
---

Siêu phẳng là một trong những đối tượng hình học cơ bản nhất trong tối ưu hóa lồi và đại số tuyến tính. Nó đóng vai trò như một khối xây dựng để hiểu các tập lồi phức tạp hơn và đóng vai trò quan trọng trong các thuật toán tối ưu hóa, machine learning và phân tích hình học.

## Định nghĩa Siêu phẳng

Một **siêu phẳng** trong $$\mathbb{R}^n$$ là một tập hợp có dạng:

> $$\mathcal{H} = \{x \in \mathbb{R}^n : a^T x = b\}$$

trong đó $$a \in \mathbb{R}^n$$ là một vector khác không ($$a \neq 0$$) và $$b \in \mathbb{R}$$ là một số vô hướng.

Vector $$a$$ được gọi là **vector pháp tuyến** của siêu phẳng, và nó xác định hướng của siêu phẳng. Số vô hướng $$b$$ xác định vị trí của siêu phẳng so với gốc tọa độ.

### Giải thích Hình học

- Trong $$\mathbb{R}^2$$: Một siêu phẳng là một **đường thẳng**
- Trong $$\mathbb{R}^3$$: Một siêu phẳng là một **mặt phẳng**  
- Trong $$\mathbb{R}^n$$ ($$n > 3$$): Một siêu phẳng là một không gian con $$(n-1)$$ chiều

Siêu phẳng chia toàn bộ không gian $$\mathbb{R}^n$$ thành hai **nửa không gian**:
- **Nửa không gian dương**: $$\{x : a^T x \geq b\}$$
- **Nửa không gian âm**: $$\{x : a^T x \leq b\}$$

## Tính chất của Siêu phẳng

### 1. Tính chất Tập Affine
Mọi siêu phẳng đều là **tập affine**. Điều này có nghĩa là nếu $$x_1, x_2 \in \mathcal{H}$$, thì toàn bộ đường thẳng đi qua chúng cũng được chứa trong $$\mathcal{H}$$:

$$\theta x_1 + (1-\theta) x_2 \in \mathcal{H} \quad \forall \theta \in \mathbb{R}$$

**Chứng minh**: Nếu $$a^T x_1 = b$$ và $$a^T x_2 = b$$, thì:
$$a^T(\theta x_1 + (1-\theta) x_2) = \theta a^T x_1 + (1-\theta) a^T x_2 = \theta b + (1-\theta) b = b$$

### 2. Tính chất Tập Lồi
Vì mọi tập affine đều là lồi, siêu phẳng là **tập lồi**. Với bất kỳ $$x_1, x_2 \in \mathcal{H}$$ và $$\lambda \in [0,1]$$:

$$\lambda x_1 + (1-\lambda) x_2 \in \mathcal{H}$$

### 3. Tính chất Tập Đóng
Siêu phẳng là **tập đóng** vì chúng là tập mức của các hàm tuyến tính liên tục.

### 4. Chiều
Một siêu phẳng trong $$\mathbb{R}^n$$ có chiều $$n-1$$.

## Các cách biểu diễn khác

### 1. Dạng Điểm-Pháp tuyến
Nếu chúng ta biết một điểm $$x_0$$ trên siêu phẳng và vector pháp tuyến $$a$$, siêu phẳng có thể được viết như:

$$\mathcal{H} = \{x : a^T (x - x_0) = 0\}$$

Điều này tương đương với $$a^T x = a^T x_0$$, vậy $$b = a^T x_0$$.

### 2. Dạng Ma trận
Một siêu phẳng cũng có thể được biểu diễn bằng ký hiệu ma trận. Nếu $$A$$ là ma trận $$1 \times n$$ (vector hàng), thì:

$$\mathcal{H} = \{x : Ax = b\}$$

### 3. Dạng Tham số
Một siêu phẳng có thể được tham số hóa bằng cách sử dụng một cơ sở cho không gian null của nó. Nếu $$\{v_1, v_2, \ldots, v_{n-1}\}$$ là một cơ sở trực chuẩn cho không gian null của $$a^T$$, và $$x_0$$ là bất kỳ điểm nào trên siêu phẳng, thì:

$$\mathcal{H} = \{x_0 + t_1 v_1 + t_2 v_2 + \cdots + t_{n-1} v_{n-1} : t_i \in \mathbb{R}\}$$

## Khoảng cách từ Điểm đến Siêu phẳng

**Khoảng cách** từ một điểm $$x_0$$ đến siêu phẳng $$\{x : a^T x = b\}$$ được cho bởi:

$$d(x_0, \mathcal{H}) = \frac{\lvert a^T x_0 - b \rvert}{\lVert a \rVert_2}$$

Công thức này xuất phát từ việc chiếu vector từ bất kỳ điểm nào trên siêu phẳng đến $$x_0$$ lên hướng pháp tuyến.

### Suy dẫn
Gọi $$x^*$$ là điểm gần nhất trên siêu phẳng với $$x_0$$. Thì $$x^* - x_0$$ song song với vector pháp tuyến $$a$$:

$$x^* - x_0 = t \frac{a}{\lVert a \rVert_2}$$

Vì $$x^* \in \mathcal{H}$$, ta có $$a^T x^* = b$$. Thay thế:

$$a^T \left(x_0 + t \frac{a}{\lVert a \rVert_2}\right) = b$$

Giải tìm $$t$$: $$t = \frac{b - a^T x_0}{\lVert a \rVert_2}$$

Khoảng cách là $$\lvert t \rvert = \frac{\lvert a^T x_0 - b \rvert}{\lVert a \rVert_2}$$.

## Ví dụ

### Ví dụ 1: Đường thẳng trong $$\mathbb{R}^2$$
Siêu phẳng $$2x_1 + 3x_2 = 6$$ biểu diễn một đường thẳng trong mặt phẳng.
- Vector pháp tuyến: $$a = (2, 3)$$
- Đường thẳng đi qua các điểm $$(3, 0)$$ và $$(0, 2)$$
- Khoảng cách từ gốc tọa độ: $$\frac{\lvert 2 \cdot 0 + 3 \cdot 0 - 6 \rvert}{\sqrt{2^2 + 3^2}} = \frac{6}{\sqrt{13}}$$

### Ví dụ 2: Mặt phẳng trong $$\mathbb{R}^3$$
Siêu phẳng $$x_1 - 2x_2 + x_3 = 4$$ biểu diễn một mặt phẳng trong không gian 3D.
- Vector pháp tuyến: $$a = (1, -2, 1)$$
- Mặt phẳng đi qua các điểm $$(4, 0, 0)$$, $$(0, -2, 0)$$, và $$(0, 0, 4)$$

### Ví dụ 3: Siêu phẳng đi qua Gốc tọa độ
Siêu phẳng $$a^T x = 0$$ luôn đi qua gốc tọa độ và thực sự là một **không gian con** có chiều $$n-1$$.

## Trực quan hóa Tương tác

[Ghi chú: Phần này chứa mã JavaScript để tạo trực quan hóa tương tác về siêu phẳng. Phần này sẽ được dịch riêng do tính phức tạp của mã.]

## Mối quan hệ với các Khái niệm khác

### Kết nối với Tập Affine
Mọi siêu phẳng đều là tập affine, nhưng không phải mọi tập affine đều là siêu phẳng. Siêu phẳng là các tập affine có chiều $$(n-1)$$ cụ thể trong $$\mathbb{R}^n$$.

### Kết nối với Đại số Tuyến tính
Siêu phẳng $$\{x : a^T x = b\}$$ là **tập mức** của hàm tuyến tính $$f(x) = a^T x$$ tại mức $$b$$. Gradient của hàm này là hằng số và bằng $$a$$, điều này giải thích tại sao $$a$$ vuông góc với siêu phẳng.

### Kết nối với Tối ưu hóa
Trong tối ưu hóa có ràng buộc, các ràng buộc đẳng thức thường định nghĩa các siêu phẳng hạn chế miền khả thi. Phương pháp nhân tử Lagrange khai thác thực tế rằng tại điểm tối ưu, gradient của hàm mục tiêu song song với vector pháp tuyến của siêu phẳng ràng buộc.

## Interactive Visualization

<div id="hyperplane-container" style="width: 100%; max-width: 800px; margin: 20px auto;">
    <div id="controls" style="margin-bottom: 20px; text-align: center;">
        <label>Normal vector a₁: <input type="range" id="a1-slider" min="-3" max="3" step="0.1" value="1"></label>
        <span id="a1-value">1.0</span><br>
        <label>Normal vector a₂: <input type="range" id="a2-slider" min="-3" max="3" step="0.1" value="1"></label>
        <span id="a2-value">1.0</span><br>
        <label>Offset b: <input type="range" id="b-slider" min="-5" max="5" step="0.1" value="0"></label>
        <span id="b-value">0.0</span><br>
        <button id="reset-btn">Reset</button>
    </div>
    <canvas id="hyperplane-canvas" width="600" height="400" style="border: 1px solid #ccc; display: block; margin: 0 auto;"></canvas>
    <div id="info" style="text-align: center; margin-top: 10px; font-family: monospace;">
        <p>Hyperplane equation: <span id="equation">x₁ + x₂ = 0</span></p>
        <p>Distance from origin: <span id="distance">0.0</span></p>
    </div>
</div>

<script>
class HyperplaneVisualizer {
    constructor() {
        this.canvas = document.getElementById('hyperplane-canvas');
        this.ctx = this.canvas.getContext('2d');
        this.width = this.canvas.width;
        this.height = this.canvas.height;
        
        // Parameters
        this.a1 = 1;
        this.a2 = 1;
        this.b = 0;
        
        // Scale and offset for coordinate system
        this.scale = 40;
        this.centerX = this.width / 2;
        this.centerY = this.height / 2;
        
        this.setupControls();
        this.draw();
    }
    
    setupControls() {
        const a1Slider = document.getElementById('a1-slider');
        const a2Slider = document.getElementById('a2-slider');
        const bSlider = document.getElementById('b-slider');
        const resetBtn = document.getElementById('reset-btn');
        
        a1Slider.addEventListener('input', (e) => {
            this.a1 = parseFloat(e.target.value);
            document.getElementById('a1-value').textContent = this.a1.toFixed(1);
            this.updateDisplay();
        });
        
        a2Slider.addEventListener('input', (e) => {
            this.a2 = parseFloat(e.target.value);
            document.getElementById('a2-value').textContent = this.a2.toFixed(1);
            this.updateDisplay();
        });
        
        bSlider.addEventListener('input', (e) => {
            this.b = parseFloat(e.target.value);
            document.getElementById('b-value').textContent = this.b.toFixed(1);
            this.updateDisplay();
        });
        
        resetBtn.addEventListener('click', () => {
            this.a1 = 1;
            this.a2 = 1;
            this.b = 0;
            a1Slider.value = 1;
            a2Slider.value = 1;
            bSlider.value = 0;
            document.getElementById('a1-value').textContent = '1.0';
            document.getElementById('a2-value').textContent = '1.0';
            document.getElementById('b-value').textContent = '0.0';
            this.updateDisplay();
        });
    }
    
    updateDisplay() {
        this.draw();
        this.updateInfo();
    }
    
    updateInfo() {
        // Update equation
        const eq = `${this.a1.toFixed(1)}x₁ + ${this.a2.toFixed(1)}x₂ = ${this.b.toFixed(1)}`;
        document.getElementById('equation').textContent = eq;
        
        // Update distance from origin
        const distance = Math.abs(this.b) / Math.sqrt(this.a1 * this.a1 + this.a2 * this.a2);
        document.getElementById('distance').textContent = distance.toFixed(3);
    }
    
    worldToScreen(x, y) {
        return {
            x: this.centerX + x * this.scale,
            y: this.centerY - y * this.scale
        };
    }
    
    draw() {
        // Clear canvas
        this.ctx.clearRect(0, 0, this.width, this.height);
        
        // Draw coordinate system
        this.drawCoordinateSystem();
        
        // Draw hyperplane (line in 2D)
        this.drawHyperplane();
        
        // Draw normal vector
        this.drawNormalVector();
        
        // Draw distance from origin
        this.drawDistanceFromOrigin();
    }
    
    drawCoordinateSystem() {
        this.ctx.strokeStyle = '#ddd';
        this.ctx.lineWidth = 1;
        
        // Grid lines
        for (let i = -10; i <= 10; i++) {
            if (i === 0) continue;
            
            // Vertical lines
            const x = this.centerX + i * this.scale;
            this.ctx.beginPath();
            this.ctx.moveTo(x, 0);
            this.ctx.lineTo(x, this.height);
            this.ctx.stroke();
            
            // Horizontal lines
            const y = this.centerY + i * this.scale;
            this.ctx.beginPath();
            this.ctx.moveTo(0, y);
            this.ctx.lineTo(this.width, y);
            this.ctx.stroke();
        }
        
        // Axes
        this.ctx.strokeStyle = '#666';
        this.ctx.lineWidth = 2;
        
        // X-axis
        this.ctx.beginPath();
        this.ctx.moveTo(0, this.centerY);
        this.ctx.lineTo(this.width, this.centerY);
        this.ctx.stroke();
        
        // Y-axis
        this.ctx.beginPath();
        this.ctx.moveTo(this.centerX, 0);
        this.ctx.lineTo(this.centerX, this.height);
        this.ctx.stroke();
        
        // Labels
        this.ctx.fillStyle = '#666';
        this.ctx.font = '12px Arial';
        this.ctx.fillText('x₁', this.width - 20, this.centerY - 10);
        this.ctx.fillText('x₂', this.centerX + 10, 15);
    }
    
    drawHyperplane() {
        if (Math.abs(this.a1) < 1e-10 && Math.abs(this.a2) < 1e-10) return;
        
        this.ctx.strokeStyle = '#2196F3';
        this.ctx.lineWidth = 3;
        
        // Find two points on the line a1*x1 + a2*x2 = b
        let x1_start, y1_start, x1_end, y1_end;
        
        if (Math.abs(this.a2) > 1e-10) {
            // Line is not vertical
            x1_start = -10;
            y1_start = (this.b - this.a1 * x1_start) / this.a2;
            x1_end = 10;
            y1_end = (this.b - this.a1 * x1_end) / this.a2;
        } else {
            // Line is vertical
            x1_start = x1_end = this.b / this.a1;
            y1_start = -10;
            y1_end = 10;
        }
        
        const start = this.worldToScreen(x1_start, y1_start);
        const end = this.worldToScreen(x1_end, y1_end);
        
        this.ctx.beginPath();
        this.ctx.moveTo(start.x, start.y);
        this.ctx.lineTo(end.x, end.y);
        this.ctx.stroke();
        
        // Label
        const midX = (start.x + end.x) / 2;
        const midY = (start.y + end.y) / 2;
        this.ctx.fillStyle = '#2196F3';
        this.ctx.font = 'bold 14px Arial';
        this.ctx.fillText('Hyperplane', midX + 10, midY - 10);
    }
    
    drawNormalVector() {
        if (Math.abs(this.a1) < 1e-10 && Math.abs(this.a2) < 1e-10) return;
        
        // Normalize the normal vector for display
        const norm = Math.sqrt(this.a1 * this.a1 + this.a2 * this.a2);
        const na1 = this.a1 / norm;
        const na2 = this.a2 / norm;
        
        // Find a point on the hyperplane closest to origin
        const t = this.b / (this.a1 * this.a1 + this.a2 * this.a2);
        const px = t * this.a1;
        const py = t * this.a2;
        
        const startPoint = this.worldToScreen(px, py);
        const endPoint = this.worldToScreen(px + na1 * 2, py + na2 * 2);
        
        // Draw normal vector
        this.ctx.strokeStyle = '#FF5722';
        this.ctx.lineWidth = 2;
        this.ctx.beginPath();
        this.ctx.moveTo(startPoint.x, startPoint.y);
        this.ctx.lineTo(endPoint.x, endPoint.y);
        this.ctx.stroke();
        
        // Draw arrowhead
        const angle = Math.atan2(endPoint.y - startPoint.y, endPoint.x - startPoint.x);
        const arrowLength = 10;
        this.ctx.beginPath();
        this.ctx.moveTo(endPoint.x, endPoint.y);
        this.ctx.lineTo(
            endPoint.x - arrowLength * Math.cos(angle - Math.PI / 6),
            endPoint.y - arrowLength * Math.sin(angle - Math.PI / 6)
        );
        this.ctx.moveTo(endPoint.x, endPoint.y);
        this.ctx.lineTo(
            endPoint.x - arrowLength * Math.cos(angle + Math.PI / 6),
            endPoint.y - arrowLength * Math.sin(angle + Math.PI / 6)
        );
        this.ctx.stroke();
        
        // Label
        this.ctx.fillStyle = '#FF5722';
        this.ctx.font = 'bold 12px Arial';
        this.ctx.fillText('Normal vector a', endPoint.x + 5, endPoint.y - 5);
    }
    
    drawDistanceFromOrigin() {
        if (Math.abs(this.a1) < 1e-10 && Math.abs(this.a2) < 1e-10) return;
        
        // Find closest point on hyperplane to origin
        const t = this.b / (this.a1 * this.a1 + this.a2 * this.a2);
        const px = t * this.a1;
        const py = t * this.a2;
        
        const origin = this.worldToScreen(0, 0);
        const closestPoint = this.worldToScreen(px, py);
        
        // Draw distance line
        this.ctx.strokeStyle = '#4CAF50';
        this.ctx.lineWidth = 2;
        this.ctx.setLineDash([5, 5]);
        this.ctx.beginPath();
        this.ctx.moveTo(origin.x, origin.y);
        this.ctx.lineTo(closestPoint.x, closestPoint.y);
        this.ctx.stroke();
        this.ctx.setLineDash([]);
        
        // Draw origin point
        this.ctx.fillStyle = '#4CAF50';
        this.ctx.beginPath();
        this.ctx.arc(origin.x, origin.y, 4, 0, 2 * Math.PI);
        this.ctx.fill();
        
        // Draw closest point
        this.ctx.beginPath();
        this.ctx.arc(closestPoint.x, closestPoint.y, 4, 0, 2 * Math.PI);
        this.ctx.fill();
        
        // Label
        const midX = (origin.x + closestPoint.x) / 2;
        const midY = (origin.y + closestPoint.y) / 2;
        this.ctx.fillStyle = '#4CAF50';
        this.ctx.font = '12px Arial';
        this.ctx.fillText('Distance', midX + 5, midY + 5);
    }
}

// Initialize visualization when page loads
document.addEventListener('DOMContentLoaded', function() {
    new HyperplaneVisualizer();
});
</script>

## Relationship to Other Concepts

### Connection to Affine Sets
Every hyperplane is an affine set, but not every affine set is a hyperplane. Hyperplanes are specifically $$(n-1)$$-dimensional affine sets in $$\mathbb{R}^n$$.

### Connection to Linear Algebra
The hyperplane $$\{x : a^T x = b\}$$ is the **level set** of the linear function $$f(x) = a^T x$$ at level $$b$$. The gradient of this function is constant and equal to $$a$$, which explains why $$a$$ is perpendicular to the hyperplane.

### Connection to Optimization
In constrained optimization, equality constraints often define hyperplanes that restrict the feasible region. The method of Lagrange multipliers exploits the fact that at an optimal point, the gradient of the objective function is parallel to the normal vector of the constraint hyperplane.