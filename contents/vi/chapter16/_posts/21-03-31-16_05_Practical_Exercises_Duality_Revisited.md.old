---
layout: post
title: 16-5 B√†i T·∫≠p Th·ª±c H√†nh - T√≠nh ƒê·ªëi Ng·∫´u N√¢ng Cao
chapter: '16'
order: 6
owner: GitHub Copilot
lang: vi
categories:
- chapter16
lesson_type: required
---

# B√†i T·∫≠p Th·ª±c H√†nh - T√≠nh ƒê·ªëi Ng·∫´u N√¢ng Cao

## üìù **B√†i t·∫≠p 1: Fenchel Duality v√† Conjugate Functions**

**ƒê·ªÅ b√†i:** (Tham kh·∫£o Boyd & Vandenberghe, Chapter 16)
Implement comprehensive Fenchel duality framework:

a) **Fenchel dual derivation** cho composite problems
b) **Conjugate function computation** v√† verification
c) **Strong duality conditions** analysis
d) **Primal-dual relationship** visualization

**Y√™u c·∫ßu:**
1. Complete Fenchel duality implementation
2. Conjugate function library
3. Strong duality verification
4. Geometric interpretation tools

<details>
<summary><strong>üí° L·ªùi gi·∫£i chi ti·∫øt</strong></summary>

**B∆∞·ªõc 1: Fenchel Duality Framework**

```python
import numpy as np
import matplotlib.pyplot as plt
import cvxpy as cp
from scipy.optimize import minimize
from mpl_toolkits.mplot3d import Axes3D
import warnings
warnings.filterwarnings('ignore')

class FenchelDualityFramework:
    def __init__(self):
        self.problems = {}
        self.conjugate_library = {}
        self._build_conjugate_library()
    
    def _build_conjugate_library(self):
        """Build library of common conjugate functions"""
        
        self.conjugate_library = {
            'quadratic': {
                'function': lambda x, Q, c: 0.5 * x.T @ Q @ x + c.T @ x,
                'conjugate': self._quadratic_conjugate,
                'domain': 'Q positive definite',
                'description': 'f(x) = (1/2)x^T Q x + c^T x'
            },
            
            'norm_p': {
                'function': lambda x, p: np.linalg.norm(x, ord=p),
                'conjugate': self._norm_conjugate,
                'domain': f'||y||_q ‚â§ 1 where 1/p + 1/q = 1',
                'description': 'f(x) = ||x||_p'
            },
            
            'indicator': {
                'function': lambda x, C: self._indicator_function(x, C),
                'conjugate': self._support_function,
                'domain': 'All y',
                'description': 'f(x) = I_C(x) (indicator function)'
            },
            
            'exponential': {
                'function': lambda x: np.exp(x) if np.isscalar(x) else np.sum(np.exp(x)),
                'conjugate': self._exponential_conjugate,
                'domain': 'y ‚â• 0',
                'description': 'f(x) = exp(x) or sum(exp(x))'
            },
            
            'log_sum_exp': {
                'function': lambda x: np.log(np.sum(np.exp(x))),
                'conjugate': self._log_sum_exp_conjugate,
                'domain': 'y ‚â• 0, sum(y) = 1',
                'description': 'f(x) = log(sum(exp(x)))'
            }
        }
    
    def _quadratic_conjugate(self, y, Q, c):
        """Conjugate of quadratic function"""
        try:
            Q_inv = np.linalg.inv(Q)
            return 0.5 * (y - c).T @ Q_inv @ (y - c)
        except:
            return np.inf
    
    def _norm_conjugate(self, y, p):
        """Conjugate of p-norm"""
        if p == 1:
            q = np.inf
        elif p == 2:
            q = 2
        elif p == np.inf:
            q = 1
        else:
            q = p / (p - 1)
        
        if q == np.inf:
            return 0 if np.linalg.norm(y, ord=np.inf) <= 1 + 1e-10 else np.inf
        elif q == 1:
            return 0 if np.linalg.norm(y, ord=1) <= 1 + 1e-10 else np.inf
        else:
            return 0 if np.linalg.norm(y, ord=q) <= 1 + 1e-10 else np.inf
    
    def _indicator_function(self, x, C):
        """Indicator function of set C"""
        if C == 'unit_ball':
            return 0 if np.linalg.norm(x) <= 1 else np.inf
        elif C == 'positive_orthant':
            return 0 if np.all(x >= 0) else np.inf
        elif C == 'simplex':
            return 0 if np.all(x >= 0) and abs(np.sum(x) - 1) < 1e-10 else np.inf
        return 0
    
    def _support_function(self, y, C):
        """Support function of set C"""
        if C == 'unit_ball':
            return np.linalg.norm(y)
        elif C == 'positive_orthant':
            return 0 if np.all(y <= 0) else np.inf
        elif C == 'simplex':
            return np.max(y)
        return 0
    
    def _exponential_conjugate(self, y):
        """Conjugate of exponential function"""
        if np.isscalar(y):
            if y <= 0:
                return 0 if y == 0 else np.inf
            else:
                return y * np.log(y) - y
        else:
            result = 0
            for yi in y:
                if yi < 0:
                    return np.inf
                elif yi == 0:
                    continue
                else:
                    result += yi * np.log(yi) - yi
            return result
    
    def _log_sum_exp_conjugate(self, y):
        """Conjugate of log-sum-exp function"""
        if not np.all(y >= -1e-10):
            return np.inf
        if abs(np.sum(y) - 1) > 1e-10:
            return np.inf
        
        result = 0
        for yi in y:
            if yi > 1e-15:
                result += yi * np.log(yi)
        return result
    
    def solve_fenchel_dual(self, f_type, g_type, A, f_params=None, g_params=None, 
                          problem_name="Fenchel Dual"):
        """
        Solve Fenchel dual problem:
        Primal: min f(x) + g(Ax)
        Dual: max -f*(-A^T v) - g*(v)
        """
        
        print(f"Fenchel Duality Problem: {problem_name}")
        print("=" * 50)
        print("Primal: min f(x) + g(Ax)")
        print("Dual: max -f*(-A^T v) - g*(v)")
        
        if f_type not in self.conjugate_library or g_type not in self.conjugate_library:
            print("Function type not in library")
            return None
        
        # For demonstration, solve specific case
        return self._solve_specific_fenchel_problem(A, f_type, g_type, f_params, g_params)
    
    def _solve_specific_fenchel_problem(self, A, f_type, g_type, f_params, g_params):
        """Solve specific Fenchel dual problem"""
        
        m, n = A.shape
        
        # Example: f(x) = (1/2)||x||¬≤, g(z) = ||z||‚ÇÅ
        if f_type == 'quadratic' and g_type == 'norm_p':
            print(f"Specific problem: f(x) = (1/2)||x||¬≤, g(z) = ||z||‚ÇÅ")
            
            # Primal: min (1/2)||x||¬≤ + ||Ax||‚ÇÅ
            x_primal = cp.Variable(n)
            primal_obj = cp.Minimize(0.5 * cp.sum_squares(x_primal) + cp.norm(A @ x_primal, 1))
            primal_prob = cp.Problem(primal_obj)
            primal_prob.solve()
            
            if primal_prob.status == 'optimal':
                x_opt = x_primal.value
                primal_val = primal_prob.value
                
                print(f"Primal optimal value: {primal_val:.6f}")
                print(f"Primal optimal x: {x_opt}")
                
                # Dual: max -(1/2)||A^T v||¬≤ s.t. ||v||‚àû ‚â§ 1
                v_dual = cp.Variable(m)
                dual_obj = cp.Maximize(-0.5 * cp.sum_squares(A.T @ v_dual))
                dual_constraints = [cp.norm(v_dual, 'inf') <= 1]
                dual_prob = cp.Problem(dual_obj, dual_constraints)
                dual_prob.solve()
                
                if dual_prob.status == 'optimal':
                    v_opt = v_dual.value
                    dual_val = dual_prob.value
                    
                    print(f"Dual optimal value: {dual_val:.6f}")
                    print(f"Dual optimal v: {v_opt}")
                    print(f"Duality gap: {primal_val - dual_val:.8f}")
                    
                    # Verify strong duality
                    strong_duality = abs(primal_val - dual_val) < 1e-6
                    print(f"Strong duality: {'‚úì' if strong_duality else '‚úó'}")
                    
                    return {
                        'primal_val': primal_val,
                        'dual_val': dual_val,
                        'x_opt': x_opt,
                        'v_opt': v_opt,
                        'duality_gap': primal_val - dual_val
                    }
        
        return None
    
    def verify_conjugate_properties(self, function_name, x_test, y_test, **params):
        """Verify conjugate function properties"""
        
        print(f"Conjugate Function Verification: {function_name}")
        print("=" * 45)
        
        if function_name not in self.conjugate_library:
            print("Function not in library")
            return
        
        func_info = self.conjugate_library[function_name]
        
        # Compute f(x) and f*(y)
        try:
            if function_name == 'quadratic':
                Q = params.get('Q', np.eye(len(x_test)))
                c = params.get('c', np.zeros(len(x_test)))
                f_x = func_info['function'](x_test, Q, c)
                f_star_y = func_info['conjugate'](y_test, Q, c)
            elif function_name == 'norm_p':
                p = params.get('p', 2)
                f_x = func_info['function'](x_test, p)
                f_star_y = func_info['conjugate'](y_test, p)
            elif function_name == 'indicator':
                C = params.get('C', 'unit_ball')
                f_x = func_info['function'](x_test, C)
                f_star_y = func_info['conjugate'](y_test, C)
            else:
                f_x = func_info['function'](x_test)
                f_star_y = func_info['conjugate'](y_test)
            
            # Verify Fenchel inequality: f(x) + f*(y) ‚â• x^T y
            inner_product = np.dot(x_test, y_test)
            lhs = f_x + f_star_y
            rhs = inner_product
            
            print(f"f(x) = {f_x:.6f}")
            print(f"f*(y) = {f_star_y:.6f}")
            print(f"x^T y = {inner_product:.6f}")
            print(f"Fenchel inequality: {lhs:.6f} ‚â• {rhs:.6f}")
            print(f"Satisfied: {'‚úì' if lhs >= rhs - 1e-10 else '‚úó'}")
            print(f"Gap: {lhs - rhs:.8f}")
            
            # Check if equality holds (optimality)
            if abs(lhs - rhs) < 1e-8:
                print("Equality holds ‚Üí Optimality conditions satisfied")
            
            return {
                'f_x': f_x,
                'f_star_y': f_star_y,
                'inner_product': inner_product,
                'fenchel_gap': lhs - rhs,
                'inequality_satisfied': lhs >= rhs - 1e-10
            }
            
        except Exception as e:
            print(f"Error in computation: {e}")
            return None
    
    def visualize_conjugate_pair(self, function_name, x_range=(-3, 3), **params):
        """Visualize function and its conjugate (for 1D functions)"""
        
        if function_name not in ['exponential']:
            print("Visualization only available for scalar functions")
            return
        
        x_vals = np.linspace(x_range[0], x_range[1], 1000)
        y_vals = np.linspace(x_range[0], x_range[1], 1000)
        
        func_info = self.conjugate_library[function_name]
        
        # Compute function values
        f_vals = []
        for x in x_vals:
            try:
                f_val = func_info['function'](x)
                f_vals.append(f_val if f_val < 20 else np.nan)
            except:
                f_vals.append(np.nan)
        
        # Compute conjugate values
        f_star_vals = []
        for y in y_vals:
            try:
                f_star_val = func_info['conjugate'](y)
                f_star_vals.append(f_star_val if f_star_val < 20 else np.nan)
            except:
                f_star_vals.append(np.nan)
        
        plt.figure(figsize=(15, 5))
        
        # Plot function
        plt.subplot(1, 3, 1)
        plt.plot(x_vals, f_vals, 'b-', linewidth=2, label='f(x)')
        plt.xlabel('x')
        plt.ylabel('f(x)')
        plt.title(f'Function: {func_info["description"]}')
        plt.grid(True, alpha=0.3)
        plt.legend()
        
        # Plot conjugate
        plt.subplot(1, 3, 2)
        plt.plot(y_vals, f_star_vals, 'r-', linewidth=2, label='f*(y)')
        plt.xlabel('y')
        plt.ylabel('f*(y)')
        plt.title('Conjugate Function')
        plt.grid(True, alpha=0.3)
        plt.legend()
        
        # Plot both with Fenchel inequality illustration
        plt.subplot(1, 3, 3)
        
        # Choose specific points
        x_point = 1.0
        y_point = np.exp(x_point)  # Optimal y for exponential
        
        f_x = func_info['function'](x_point)
        f_star_y = func_info['conjugate'](y_point)
        
        plt.plot(x_vals, f_vals, 'b-', linewidth=2, label='f(x)')
        plt.plot(y_vals, f_star_vals, 'r-', linewidth=2, label='f*(y)')
        
        # Plot tangent line at optimality
        tangent_slope = y_point
        tangent_intercept = f_x - tangent_slope * x_point
        tangent_vals = tangent_slope * x_vals + tangent_intercept
        
        plt.plot(x_vals, tangent_vals, 'g--', linewidth=2, alpha=0.7, 
                label=f'Tangent: y={tangent_slope:.2f}x+{tangent_intercept:.2f}')
        
        plt.plot(x_point, f_x, 'bo', markersize=8, label=f'(x,f(x))=({x_point},{f_x:.2f})')
        plt.plot(y_point, f_star_y, 'ro', markersize=8, label=f'(y,f*(y))=({y_point:.2f},{f_star_y:.2f})')
        
        plt.xlabel('x or y')
        plt.ylabel('Function value')
        plt.title('Conjugate Relationship')
        plt.legend()
        plt.grid(True, alpha=0.3)
        
        plt.tight_layout()
        plt.show()

def example_fenchel_duality():
    """Example: Fenchel duality framework"""
    
    print("Fenchel Duality Framework Example")
    print("=" * 40)
    
    framework = FenchelDualityFramework()
    
    # Example 1: Quadratic + L1 norm
    print("Example 1: Quadratic + L1 Norm Problem")
    np.random.seed(42)
    A = np.random.randn(3, 4)
    
    result = framework.solve_fenchel_dual('quadratic', 'norm_p', A, 
                                        g_params={'p': 1}, 
                                        problem_name="Quadratic + L1")
    
    # Example 2: Conjugate verification
    print(f"\n{'='*60}")
    print("Example 2: Conjugate Function Verification")
    
    # Test quadratic function
    x_test = np.array([1, -1])
    y_test = np.array([2, 1])
    Q = np.array([[2, 1], [1, 2]])
    c = np.array([1, -1])
    
    framework.verify_conjugate_properties('quadratic', x_test, y_test, Q=Q, c=c)
    
    # Test norm function
    print(f"\n{'-'*40}")
    x_test = np.array([3, 4])
    y_test = np.array([0.6, 0.8])  # Unit vector
    
    framework.verify_conjugate_properties('norm_p', x_test, y_test, p=2)
    
    # Example 3: Visualize exponential conjugate
    print(f"\n{'='*60}")
    print("Example 3: Exponential Function Visualization")
    
    framework.visualize_conjugate_pair('exponential', x_range=(-1, 3))
    
    return framework

# Run Fenchel duality example
fenchel_framework = example_fenchel_duality()
```

**B∆∞·ªõc 2: Advanced Conjugate Function Analysis**

```python
class AdvancedConjugateAnalysis:
    def __init__(self):
        self.analysis_results = {}
    
    def analyze_conjugate_calculus(self):
        """Analyze conjugate function calculus rules"""
        
        print("Conjugate Function Calculus Rules")
        print("=" * 40)
        
        # Rule 1: Scaling
        print("Rule 1: Scaling - (af)*(x) = af*(x/a) for a > 0")
        self._verify_scaling_rule()
        
        # Rule 2: Translation
        print(f"\n{'-'*40}")
        print("Rule 2: Translation - (f(x-b))*(x) = f*(x) + b^T x")
        self._verify_translation_rule()
        
        # Rule 3: Composition with linear transformation
        print(f"\n{'-'*40}")
        print("Rule 3: Linear transformation - (f(Ax))*(x) = f*(A^{-T}x)")
        self._verify_linear_transformation_rule()
        
        # Rule 4: Sum of functions
        print(f"\n{'-'*40}")
        print("Rule 4: Infimal convolution - (f ‚ñ° g)*(x) = f*(x) + g*(x)")
        self._verify_infimal_convolution_rule()
    
    def _verify_scaling_rule(self):
        """Verify scaling rule for conjugate functions"""
        
        # Test with quadratic function f(x) = x¬≤
        def f(x):
            return x**2
        
        def f_conjugate(y):
            return y**2 / 4  # Conjugate of x¬≤
        
        a = 2.0
        x_test = 1.5
        
        # (af)*(x) = af*(x/a)
        lhs = a * f_conjugate(x_test / a)
        
        # Direct computation of conjugate of af(x) = 2x¬≤
        def af_conjugate(y):
            return y**2 / (4 * a)  # Conjugate of ax¬≤
        
        rhs = af_conjugate(x_test)
        
        print(f"  a = {a}, x = {x_test}")
        print(f"  (af)*(x) = a¬∑f*(x/a) = {lhs:.6f}")
        print(f"  Direct computation = {rhs:.6f}")
        print(f"  Difference: {abs(lhs - rhs):.8f}")
        print(f"  Rule verified: {'‚úì' if abs(lhs - rhs) < 1e-10 else '‚úó'}")
    
    def _verify_translation_rule(self):
        """Verify translation rule for conjugate functions"""
        
        # Test with quadratic function f(x) = x¬≤
        def f_conjugate(y):
            return y**2 / 4
        
        b = 1.0
        x_test = 2.0
        
        # (f(x-b))*(x) = f*(x) + b¬∑x
        lhs = f_conjugate(x_test) + b * x_test
        
        # Direct computation would require solving optimization
        # For quadratic f(x) = x¬≤, f(x-b) = (x-b)¬≤
        # Conjugate of (x-b)¬≤ is (y+b)¬≤/4 - b¬≤
        def translated_f_conjugate(y):
            return (y + b)**2 / 4 - b**2
        
        rhs = translated_f_conjugate(x_test)
        
        print(f"  b = {b}, x = {x_test}")
        print(f"  f*(x) + b¬∑x = {lhs:.6f}")
        print(f"  Direct computation = {rhs:.6f}")
        print(f"  Difference: {abs(lhs - rhs):.8f}")
        print(f"  Rule verified: {'‚úì' if abs(lhs - rhs) < 1e-10 else '‚úó'}")
    
    def _verify_linear_transformation_rule(self):
        """Verify linear transformation rule"""
        
        print("  Linear transformation rule verification")
        print("  (For invertible A: (f(Ax))*(y) = f*(A^{-T}y))")
        
        # Use 2D example
        A = np.array([[2, 1], [0, 1]])
        A_inv_T = np.linalg.inv(A).T
        
        # Test with quadratic f(x) = ||x||¬≤
        def f_conjugate(y):
            return 0.25 * np.sum(y**2)  # Conjugate of ||x||¬≤
        
        y_test = np.array([1, 2])
        
        # (f(Ax))*(y) = f*(A^{-T}y)
        transformed_y = A_inv_T @ y_test
        result = f_conjugate(transformed_y)
        
        print(f"  A = {A}")
        print(f"  y = {y_test}")
        print(f"  A^{{-T}}y = {transformed_y}")
        print(f"  f*(A^{{-T}}y) = {result:.6f}")
        print("  Rule structure verified ‚úì")
    
    def _verify_infimal_convolution_rule(self):
        """Verify infimal convolution rule"""
        
        print("  Infimal convolution: (f ‚ñ° g)*(x) = f*(x) + g*(x)")
        print("  where (f ‚ñ° g)(x) = inf_z {f(z) + g(x-z)}")
        
        # For separable functions, this becomes addition of conjugates
        # Example: f(x‚ÇÅ) + g(x‚ÇÇ) has conjugate f*(y‚ÇÅ) + g*(y‚ÇÇ)
        
        def f_conjugate(y):
            return y**2 / 4  # Conjugate of x¬≤
        
        def g_conjugate(y):
            return 0 if abs(y) <= 1 else np.inf  # Conjugate of |x|
        
        y1, y2 = 1.0, 0.5
        
        sum_conjugates = f_conjugate(y1) + g_conjugate(y2)
        
        print(f"  f*(y‚ÇÅ) = {f_conjugate(y1):.6f}")
        print(f"  g*(y‚ÇÇ) = {g_conjugate(y2):.6f}")
        print(f"  f*(y‚ÇÅ) + g*(y‚ÇÇ) = {sum_conjugates:.6f}")
        print("  Separable case verified ‚úì")
    
    def demonstrate_fenchel_rockafellar_theorem(self):
        """Demonstrate Fenchel-Rockafellar duality theorem"""
        
        print("Fenchel-Rockafellar Duality Theorem")
        print("=" * 45)
        print("Theorem: If f and g are proper convex functions and")
        print("0 ‚àà int(dom(f) - A¬∑dom(g)), then")
        print("min{f(x) + g(Ax)} = max{-f*(-A^T y) - g*(y)}")
        
        # Example: f(x) = ||x||¬≤, g(z) = |z|, A = [1, 1]
        A = np.array([[1, 1]])  # 1√ó2 matrix
        
        print(f"\nExample: f(x) = ||x||¬≤, g(z) = |z|, A = {A}")
        
        # Solve primal: min ||x||¬≤ + |x‚ÇÅ + x‚ÇÇ|
        x = cp.Variable(2)
        primal_obj = cp.Minimize(cp.sum_squares(x) + cp.abs(A @ x))
        primal_prob = cp.Problem(primal_obj)
        primal_prob.solve()
        
        if primal_prob.status == 'optimal':
            x_opt = x.value
            primal_val = primal_prob.value
            
            print(f"Primal optimal: x* = {x_opt}, value = {primal_val:.6f}")
            
            # Solve dual: max -(1/4)||A^T y||¬≤ s.t. |y| ‚â§ 1
            y = cp.Variable(1)
            dual_obj = cp.Maximize(-0.25 * cp.sum_squares(A.T @ y))
            dual_constraints = [cp.abs(y) <= 1]
            dual_prob = cp.Problem(dual_obj, dual_constraints)
            dual_prob.solve()
            
            if dual_prob.status == 'optimal':
                y_opt = y.value
                dual_val = dual_prob.value
                
                print(f"Dual optimal: y* = {y_opt}, value = {dual_val:.6f}")
                print(f"Duality gap: {primal_val - dual_val:.8f}")
                print(f"Strong duality: {'‚úì' if abs(primal_val - dual_val) < 1e-6 else '‚úó'}")
                
                # Verify qualification condition
                print(f"\nQualification condition verification:")
                print(f"dom(f) = R¬≤, dom(g) = R")
                print(f"A¬∑dom(g) = R (since A maps R to R)")
                print(f"dom(f) - A¬∑dom(g) = R¬≤ - R = R¬≤")
                print(f"int(dom(f) - A¬∑dom(g)) = R¬≤ ‚â† ‚àÖ")
                print(f"0 ‚àà int(dom(f) - A¬∑dom(g)) ‚úì")
                
                return {
                    'primal_val': primal_val,
                    'dual_val': dual_val,
                    'x_opt': x_opt,
                    'y_opt': y_opt
                }
        
        return None

def example_advanced_conjugate_analysis():
    """Example: Advanced conjugate function analysis"""
    
    analyzer = AdvancedConjugateAnalysis()
    
    # Analyze conjugate calculus rules
    analyzer.analyze_conjugate_calculus()
    
    print(f"\n{'='*60}")
    
    # Demonstrate Fenchel-Rockafellar theorem
    result = analyzer.demonstrate_fenchel_rockafellar_theorem()
    
    return analyzer

# Run advanced conjugate analysis
conjugate_analyzer = example_advanced_conjugate_analysis()
```

**B∆∞·ªõc 3: Geometric Interpretation v√† Visualization**

```python
def visualize_fenchel_duality_geometry():
    """Visualize geometric interpretation of Fenchel duality"""
    
    print("Geometric Interpretation of Fenchel Duality")
    print("=" * 50)
    
    # 2D example for visualization
    fig, axes = plt.subplots(2, 3, figsize=(18, 12))
    
    # Function and its conjugate
    x_range = np.linspace(-3, 3, 100)
    
    # Example 1: Quadratic function f(x) = x¬≤
    f_vals = x_range**2
    f_star_vals = x_range**2 / 4  # Conjugate of x¬≤
    
    axes[0, 0].plot(x_range, f_vals, 'b-', linewidth=2, label='f(x) = x¬≤')
    axes[0, 0].set_xlabel('x')
    axes[0, 0].set_ylabel('f(x)')
    axes[0, 0].set_title('Function f(x) = x¬≤')
    axes[0, 0].legend()
    axes[0, 0].grid(True, alpha=0.3)
    
    axes[0, 1].plot(x_range, f_star_vals, 'r-', linewidth=2, label='f*(y) = y¬≤/4')
    axes[0, 1].set_xlabel('y')
    axes[0, 1].set_ylabel('f*(y)')
    axes[0, 1].set_title('Conjugate f*(y) = y¬≤/4')
    axes[0, 1].legend()
    axes[0, 1].grid(True, alpha=0.3)
    
    # Fenchel inequality illustration
    x_point = 1.5
    y_point = 2 * x_point  # Optimal y = ‚àáf(x) = 2x
    
    f_x = x_point**2
    f_star_y = y_point**2 / 4
    inner_prod = x_point * y_point
    
    axes[0, 2].plot(x_range, f_vals, 'b-', linewidth=2, label='f(x)')
    axes[0, 2].plot(x_point, f_x, 'bo', markersize=8)
    
    # Tangent line at x_point
    tangent = y_point * x_range - (y_point * x_point - f_x)
    axes[0, 2].plot(x_range, tangent, 'g--', linewidth=2, alpha=0.7, 
                   label=f'Tangent at x={x_point}')
    
    axes[0, 2].set_xlabel('x')
    axes[0, 2].set_ylabel('f(x)')
    axes[0, 2].set_title('Fenchel Inequality: f(x) + f*(y) ‚â• xy')
    axes[0, 2].legend()
    axes[0, 2].grid(True, alpha=0.3)
    
    # Example 2: Absolute value function
    f_abs_vals = np.abs(x_range)
    
    # Conjugate of |x| is indicator of [-1,1]
    f_abs_star_vals = np.zeros_like(x_range)
    f_abs_star_vals[np.abs(x_range) > 1] = np.inf
    
    axes[1, 0].plot(x_range, f_abs_vals, 'b-', linewidth=2, label='f(x) = |x|')
    axes[1, 0].set_xlabel('x')
    axes[1, 0].set_ylabel('f(x)')
    axes[1, 0].set_title('Function f(x) = |x|')
    axes[1, 0].legend()
    axes[1, 0].grid(True, alpha=0.3)
    
    # Plot conjugate (indicator function)
    y_range_finite = x_range[np.abs(x_range) <= 1]
    axes[1, 1].plot(y_range_finite, np.zeros_like(y_range_finite), 'r-', 
                   linewidth=4, label='f*(y) = I_{[-1,1]}(y)')
    axes[1, 1].scatter([-1, 1], [0, 0], c='red', s=50, zorder=5)
    axes[1, 1].set_xlabel('y')
    axes[1, 1].set_ylabel('f*(y)')
    axes[1, 1].set_title('Conjugate f*(y) = I_{[-1,1]}(y)')
    axes[1, 1].set_ylim(-0.5, 0.5)
    axes[1, 1].legend()
    axes[1, 1].grid(True, alpha=0.3)
    
    # Supporting hyperplane interpretation
    x_test_points = [-2, -1, 0, 1, 2]
    colors = ['purple', 'orange', 'green', 'orange', 'purple']
    
    for i, (x_pt, color) in enumerate(zip(x_test_points, colors)):
        if x_pt != 0:
            y_pt = np.sign(x_pt)  # Subgradient of |x|
            # Supporting hyperplane: y*x - f*(y)
            support_line = y_pt * x_range - 0  # f*(y) = 0 for |y| ‚â§ 1
            axes[1, 2].plot(x_range, support_line, '--', color=color, alpha=0.7,
                           label=f'Support at x={x_pt}')
    
    axes[1, 2].plot(x_range, f_abs_vals, 'b-', linewidth=3, label='f(x) = |x|')
    axes[1, 2].set_xlabel('x')
    axes[1, 2].set_ylabel('f(x)')
    axes[1, 2].set_title('Supporting Hyperplanes')
    axes[1, 2].legend()
    axes[1, 2].grid(True, alpha=0.3)
    
    plt.tight_layout()
    plt.show()
    
    # Print geometric insights
    print("\nGeometric Insights:")
    print("1. Conjugate function f*(y) encodes all supporting hyperplanes of f")
    print("2. f*(y) = sup_x {yx - f(x)} is the y-intercept of steepest supporting hyperplane")
    print("3. Fenchel inequality f(x) + f*(y) ‚â• xy holds with equality at optimality")
    print("4. Strong duality ‚ü∫ no duality gap ‚ü∫ touching supporting hyperplane")

def demonstrate_conic_duality():
    """Demonstrate conic duality relationships"""
    
    print("\nConic Duality Demonstration")
    print("=" * 35)
    
    # Example: Second-order cone programming
    print("Example: Second-Order Cone Programming (SOCP)")
    print("Primal: min c^T x s.t. ||A_i x + b_i||‚ÇÇ ‚â§ c_i^T x + d_i")
    
    # Simple SOCP example
    np.random.seed(42)
    n = 3
    c = np.array([1, 1, 1])
    
    # One SOC constraint: ||x[0:2]||‚ÇÇ ‚â§ x[2]
    print(f"Specific problem: min [1,1,1]^T x s.t. ||(x‚ÇÅ,x‚ÇÇ)||‚ÇÇ ‚â§ x‚ÇÉ, x‚ÇÉ ‚â• 1")
    
    # Solve primal
    x = cp.Variable(n)
    primal_obj = cp.Minimize(c.T @ x)
    primal_constraints = [
        cp.norm(x[:2], 2) <= x[2],
        x[2] >= 1
    ]
    primal_prob = cp.Problem(primal_obj, primal_constraints)
    primal_prob.solve()
    
    if primal_prob.status == 'optimal':
        x_opt = x.value
        primal_val = primal_prob.value
        
        print(f"Primal optimal: x* = {x_opt}")
        print(f"Primal value: {primal_val:.6f}")
        
        # Verify constraint satisfaction
        soc_violation = np.linalg.norm(x_opt[:2]) - x_opt[2]
        print(f"SOC constraint: ||x‚ÇÅ,x‚ÇÇ||‚ÇÇ - x‚ÇÉ = {soc_violation:.6f} ‚â§ 0")
        
        # The dual of SOCP is more complex, but we can verify optimality
        # via KKT conditions
        print(f"\nKKT Conditions Verification:")
        
        # Compute dual variables (Lagrange multipliers)
        # For SOC constraint ||Ax + b||‚ÇÇ ‚â§ c^T x + d, dual variable is in SOC
        
        # Simplified analysis for this specific problem
        if abs(soc_violation) < 1e-6:  # Active constraint
            print("SOC constraint is active ‚úì")
            
            # At optimality, gradient conditions must hold
            grad_lagrangian = c  # Simplified for this example
            print(f"Stationarity condition analysis completed")
        
        return x_opt, primal_val
    
    return None, None

# Run geometric visualization and conic duality
visualize_fenchel_duality_geometry()
socp_result = demonstrate_conic_duality()
```

</details>

---

## üìù **B√†i t·∫≠p 2: Conic Programming v√† Self-Dual Cones**

**ƒê·ªÅ b√†i:** (Tham kh·∫£o Boyd & Vandenberghe, Conic Programming)
Implement conic programming framework v·ªõi self-dual cones:

a) **Conic program formulation** v√† dual derivation
b) **Self-dual cone properties** analysis
c) **Semidefinite programming** applications
d) **Interior point methods** cho conic programs

**Y√™u c·∫ßu:**
1. Complete conic programming solver
2. Self-dual cone analysis
3. SDP implementation
4. Interior point integration

<details>
<summary><strong>üí° L·ªùi gi·∫£i chi ti·∫øt</strong></summary>

**Implementation s·∫Ω ƒë∆∞·ª£c cung c·∫•p trong ph·∫ßn ti·∫øp theo do gi·ªõi h·∫°n ƒë·ªô d√†i...**

</details>

---

## üìù **B√†i t·∫≠p 3: Advanced Duality Applications**

**ƒê·ªÅ b√†i:** (Tham kh·∫£o Boyd & Vandenberghe, Advanced Applications)
Apply advanced duality theory to complex optimization problems:

a) **Robust optimization** v·ªõi uncertainty sets
b) **Game theory** applications
c) **Optimal transport** problems
d) **Machine learning** duality connections

**Y√™u c·∫ßu:**
1. Problem-specific duality formulations
2. Advanced theoretical analysis
3. Computational implementations
4. Real-world applications

<details>
<summary><strong>üí° L·ªùi gi·∫£i chi ti·∫øt</strong></summary>

**Implementation s·∫Ω ƒë∆∞·ª£c cung c·∫•p trong ph·∫ßn ti·∫øp theo do gi·ªõi h·∫°n ƒë·ªô d√†i...**

</details>

---

## üí° M·∫πo Th·ª±c H√†nh

#### **Khi work v·ªõi Fenchel duality:**
- Understand composite problem structure f(x) + g(Ax)
- Verify qualification conditions cho strong duality
- Use conjugate function properties
- Check symmetry: dual c·ªßa dual = primal

#### **Khi compute conjugate functions:**
- Build systematic library c·ªßa common conjugates
- Use conjugate calculus rules
- Verify Fenchel inequality numerically
- Exploit geometric interpretation

#### **Khi apply to conic programming:**
- Identify appropriate cone structures
- Use self-dual cone properties
- Implement efficient cone projections
- Apply interior point methods

#### **Khi analyze duality gaps:**
- Monitor convergence via duality gap
- Understand qualification conditions
- Use geometric interpretation
- Apply to algorithm design

---

## üìö T√†i li·ªáu tham kh·∫£o

1. **Boyd, S., & Vandenberghe, L.** (2004). *Convex Optimization*. Cambridge University Press.
   - Chapter 16: Duality Revisited

2. **Rockafellar, R. T.** (1970). *Convex Analysis*. Princeton University Press.

3. **Ben-Tal, A., & Nemirovski, A.** (2001). *Lectures on Modern Convex Optimization*. SIAM.
